# GMP
GMP是golang中goroutine任务调度模型，G为goroutine，P为Processor，M为线程。P的数量由参数GOMAXPROCS配置，M的数量等于cpu的核数

## 设计
1. P：程序启动时创建，最多有GOMAXPROCS个。P与M完成绑定后，即可以开始执行P中的G
2. M：程序的内核线程数。一旦有一个M阻塞，就会创建一个新的M。M有空闲，也会被回收或睡眠
3. P的本地队列：一个用于放置G的本地队列，最大队列长度为256，在P中的G新建G时，会被优先加入P的本地队列中，队列满，会放在全局队列中

## 策略
1. 复用线程
   1. work stealing：在一个P的本地队列为空时，会尝试获取其他P本地队列中的G进行执行
   2. hand off：P在执行G时，如果G阻塞，P将于M解绑并让G与M绑定，然后创建/唤醒一个新的M，继续执行该P
2. 利用并行：通过GOMAXPROCS来限制P的个数
3. 抢占：每个G最多只允许使用10ms的线程，超时后会重新排队
4. 全局G队列：在进行work stealing机制时，如果所有P的本地队列中均无G，那么会从全局队列中获取G(锁保护)

## 生命周期
1. M0：程序启动后编号为0的主线程，直接保存在全局变量中，不需要在heap上进行分配。负责执行初始化操作和启动第一个G，启动完第一个G后，M0和其他M执行相同工作逻辑
2. G0：每次启动一个M，都会创建一个goroutine，这个goroutine被称为G0。G0仅负责用于调度其他的G，G0不指向任何可执行的函数。在调度或系统调用时，M都会切换到G0，再由G0调度其他G