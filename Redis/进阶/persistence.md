# 持久化

## 持久化模式
- 将当前数据进行保存，快照形式，存储数据结果，称为RDB
- 将数据的操作过程进行保存，日志形式，存储操作过程，称为AOF
- 两种模式是可以共存的

## RDB

### RDB启动方式
- 命令，手动保存一次数据，会生成一次快照信息，默认保存到dump.rdb中  
  `save`
- 命令，手动保存数据，但不是立即执行，redis会判断合适的时机fork一个**子进程**进行执行  
  `bgsave`  
- 配置，在second时间内，如果有changes个key发生变化，则进行一次`bgsave`的保存，执行后时间重置。统计changes时不会进行数据比对  
  `save secound changes`
- 恢复数据  
  `服务重新启动时将会自动从dir中恢复rdb文件`

### RDB注意事项
- 因为redis是单线程的，在执行`save`会阻塞后面的指令，所以最好不要在生产环境进行。
- redis中涉及到RDB的操作基本都是由`bgsave`进行实现，一般情况下放弃`save`
- 可以使用`redis-check-rdb`这个程序来查看rdb文件的信息

### RDB特殊的启动方式
- 全量复制
- 服务器运行过程中重启  
  `debug reload`
- 关闭服务器时执行保存  
  `shutdown save`  

### RDB优点
- RDB是一个紧凑压缩了的二进制文件，存储效率比较高
- 由于RDB是某个时间点的快照，所以非常适合用于数据备份，全量复制等场景
- RDB恢复数据的速度比AOF快很多
- 应用：服务器中每小时执行x次RDB备份，并将其拷贝到其他远程服务器中，用于灾难恢复
  
### RDB缺点
- RDB无论使用哪种启动方式都无法做到实时备份，具有较大可能性丢失数据
- bgsave需要创建子进程，牺牲了性能
- redis各版本中的rdb文件格式不统一，可能无法跨版本恢复

## AOF

### 概念
- AOF(append only file)持久化：已独立日志的方式记录每次所执行的命令，重启时再重新执行一次AOF中的命令达到恢复数据的目的
- AOF的主要作用是解决了数据持久化的实时性，目前已经是redis持久化的主流方式
  
### AOF写数据的三种策略(appendfsync)
- always(每次)  
  每次操作均同步到AOF文件中，数据零误差，性能较低，不建议使用
- everysec(每秒)  
  每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，在系统突然宕机的情况下丢失1秒数据，默认策略
- no(系统控制)  
  由操作系统控制每次同步到AOF文件的周期，整体过程不可控

### AOF配置
- 配置，是否开启AOF，默认为no  
  `appendonly yes|no`
- 配置，AOF写数据策略，默认为everysec  
  `appendfsync always|everysec|no`  

### AOF重写
随着命令不断写入AOF，文件会越来越大，为了解决这个问题，redis引入了AOF重写机制来压缩AOF文件体积。AOF文件重写是将redis进程内的数据转化为写命令并同步到AOF文件的过程。简单来说就是将对同一个命令的若干条指令执行结果转化为最终结果数据对应的指令进行记录。

- 降低磁盘占用量，提高磁盘利用率
- 提高持久化效率，降低持久化写时间，提高IO性能
- 降低恢复数据用时，提高数据恢复效率

### AOF重写规则
- 进程内超时的数据不再写
- 忽略无效指令，重写时使用进程内数据直接生成，这样新AOF文件只保留最终数据的写入命令
- 对同一条数据的多条写入指令合并为一条

### AOF重写启动方法
- 手动，命令  
  `bgrewriteaof`  
- 配置，自动重写  
  `auto-aof-rewrite-min-size size`  
  `auto-aof-rewrite-percentage percentage`