# 索引优化

1. #### 注意事项
   
   1. 全值匹配
      
      使用复合索引最好索引复合索引中全部字段，称为全值匹配。
   
   2. 最左匹配法则
      
      如果索引了多列，索引字段必须包含复合索引第一个字段，**且中间不能缺少字段**。（顺序可以打乱，因为optimizer会优化顺序）。
   
   3. 对字段使用函数
      
      在where中对字段使用函数会导致索引失效，即使是`left(name, 3) = 'abc'`这种看似能使用上索引的字段。
   
   4. 对复合索引使用范围筛选
      
      复合索引无法索引在范围查询后的字段。
      
      比如index(a,b,c)，如果使用了`where a=1 and b > 0 and c=1`则复合索引无法索引c字段。（因为可以索引a和b，所以速度还是有提高的）
   
   5. 使用不等于
      
      使用不等于判断条件会导致索引失效。
      
      sql中一般不使用不等于，不等于实现在业务代码中。
   
   6. `is null`和`is not null`
      
      `is null`会使用索引，而`is not null`会导致索引失效。
   
   7. `like`筛选
      
      使用`where xxx like '%abc%'`会导致索引失效，而前几个字母能固定时能使用索引。
      
      与范围筛选不同，like复合索引的中间字段是不会导致后面的字段无法索引的。
   
   8. 筛选条件出现自动类型转化
      
      如字段类型为varchar而筛选条件是int，会触发字段的自动类型转化，导致索引失效。

2. #### 一般性建议
   
   1. 对于单键索引，尽量选择过滤性比较好的字段来建立。
   
   2. 建立复合索引，尽量将过滤性最好的字段放在前面。
   
   3. 在进行复合索引时，尽量where复合索引中所有的字段。
   
   4. 如果某个字段可能出现范围筛选，尽量将它放在组合索引的最后。
   
   5. 尽量避免索引失效的sql语法

3. #### 关联查询的优化
   
   1. inner join时mysql会自己选择谁来做驱动表，决定因素为索引和数据量。
   
   2. left和right join时尽量将小表作为驱动表。
      
      如果mysql根据索引误将大表作为驱动表时，可以使用`straight_join`来显示指定该关键字后的表为被驱动表。
   
   3. 保证被驱动表的join字段建立好了索引。
   
   4. 能使用关联查询时，尽量不使用子查询。 
   
   5. 虚拟表是没有索引的，尽量不使用虚拟表作为被驱动表。

4. #### 排序分组优化
   
   1. 排序的字段必须吻合复合索引字段的顺序，不然索引失效。
   
   2. 升序和降序同时出现会导致索引失效。
   
   3. order by尽量使用index方式排序而不是filesort。
   
   4. filesort的双路排序和单路排序
      
      单路排序在内存中进行排序，双路排序在硬盘中进行排序，所以单路排序要快的多，但是内存开销比较大。
   
   5. group by与order by几乎一致，唯一不同是group不用必须添加过滤条件。
