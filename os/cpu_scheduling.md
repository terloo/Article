# cpu_scheduling
cpu_scheduling(进程调度，或称进程调度)，使用某种调度算法(策略)来进行进程调度

## cpu调度程序
1. 无论何时，cpu变得空闲时，操作系统会从进程等待就绪队列中挑选一个(多个)进程进行执行，这个挑选的过程被称为cpu调度程序

## 抢占调度
1. 非抢占调度(Nonpreemptive scheduling)：一旦某个进程得到CPU，就会一直占用到终止或者等待状态
2. 抢占调度(Preemptive scheduling)：进程得到CPU后，仍然可能被操作系统剥夺CPU使用权

## 调度算法性能的衡量
1. CPU利用率：CPU的繁忙程度
2. 响应时间：从提交任务到第一次响应的时间(针对交互式系统)
3. **等待时间**：进程在就绪队列中的累计等待时间
4. **周转时间**：从提交任务到完成的时间
5. 吞吐率：每个时钟单位处理的任务数
6. 公平性：以合理的方式让各个进程共享CPU

## 先来先服务FCFS
先来先服务(First-Come，First-Served)算法，一个程序会一直运行直到阻塞或者时间片耗尽，然后被追加的响应队列末尾
1. 优点：简单易实现
2. 缺点：如果短作业处在长作业之后，将会降低平均等待时间和平均周转时间

## 时间片轮转(Round Robin)
1. 每个进程都可以得到相同的CPU使用时间(CPU时间片，CPU slice)，当时间片耗尽，进程将会剥夺CPU使用权并加入就绪队列的尾部
2. 抢占式调度算法
3. n个就绪队列中的进程和时间片q
   1. 每个进程获得1/n的CPU时间片，大约是q个时间单位
   2. 没有进程等待时间会超过(n-1)q
4. 时间片选取(time slice)
   1. 取值太小：进程切换开销显著增大(不能小于进程切换时间)
   2. 取值较大：响应速度下降(无穷大时退化为FCFS)
   3. 一般时间片选取范围为10ms~100ms
   4. 上下文切换的时间大致为0.1ms~1ms(1%的cpu时间开销)
5. 优先：公平算法
6. 缺点：对长时间作业带来额外的切换开销

## 最短作业优先SJF
最短作业优先(Shortest Job First)：下一次调度时总是会选择所需CPU时间最短的那个作业
1. 非抢占调度，但可以改为抢占式(SRTF算法)
2. 该算法总是将短进程移动到长进程之前执行，因此平均等待时间最小，该算法被证明是最优的
3. 饥饿现象：长进程可能长时间无法获得CPU
4. 预测技术
   1. 该算法需要事先知道进程所需的CPU时间
   2. 预测一个进程CPU时间很困难
5. 优缺点
   1. 优化了响应时间
   2. 难以预测CPU作业时间
   3. 非公平

## 优先级调度
1. 优先级通常是固定区间的数字，如[0,10]
   1. 数字大小与优先级高低的关系在不同的操作系统中有不同的实现，如linux，数字越小优先级越大
   2. 调度策略：下一次调度时总是会选取优先级最高的进程
   3. SJF是优先级调度的一个特例
   4. 优先级调度可以是抢占式，也可以是非抢占式
2. 优先级的定义
   1. 静态优先级：进程优先级保持不变，出现不公平(饥饿)现象
   2. 动态优先级NICE值(退化Aging算法)
      1. 根据进程占用CPU的时间：当进程占有CPU时间越长，则慢慢降低它的优先级
      2. 根据进程等待CPU的时间：当进程在就绪队列中等待的时间越长，则慢慢升级它的优先级

## Linux CPU调度
Linux只支持系统级的线程的资源竞争区间(PTHREAD_SCOPE_SYSTEM)，故CPU在线程上(而不是进程)进行调度。在不进行人为设置的情况下，进程下每个线程的调度优先级是一致的。  
由于Linux使用了CFS调度器，内核中也会根据进程组为单位来限制时间片等资源的分配，保证了拥有多个线程的进程不会获得更多的时间片

## 实时线程与普通线程
1. Normal普通线程
   1. 调度策略
      1. SCHED_OTHER：最常用的调度策略。分时调度策略，调度器为CFS，动态优先级(NICE值)，NICE值越低优先级越高
      2. SCHED_IDLE：只在CPU空闲时进行调度
      3. SCHED_BATCH
2. real-time实时线程，实时线程的调度优先级总是高于普通线程，静态优先级(PR值)，PR值约小优先级越高
   1. 调度策略，按优先级抢占式
      1. SCHED_FIFO：一旦线程占用CPU则一直运行，直到被抢占。在优先级相同时，采用FIFO策略
      2. SCHED_RR：一旦线程占用CPU则一直运行，直到被抢占。在优先级相同时，采用RR策略

## 基础优先级 scheduling priority
Linux将所有线程划分为140个优先级别，取值范围为[0,139]，值越小优先级越高。但在使用这些级别时，通过会使用其他名称的级别进行对应，如NICE值，PR值，PRI值等

## NICE值
1. 静态优先级，值越小优先级越高，在实时线程中不生效
2. NICE值的范围是[-20,+19]，实际对应基础优先级的[100,139]部分
3. 新创建的进程，默认的基础优先级为120，对应NICE值为0
4. 对于实时线程，可以理解为NI值固定为-20

## PR值
1. 叠加过NI之后的动态优先级，值越小优先级越高，在实时线程中直接显示rt或负数
2. PR值值的范围是[100,139]，实际对应基础优先级的[100,139]部分
3. 由于实时线程中不显示PR值，所有PR值在显示时通常会去掉百位，显示范围为[0,39]
4. 虽然是动态优先级，但是由于Linux在2.6内核之后使用CFS调度器，故该值并不发生变化

## PRI值
1. 叠加过PR、NI、实时/非实时进程策略后的动态优先级，可以认为该值代表着进程/线程的最终优先级，**值越大优先级越高**
2. 对于实时线程，该值为`40+${priority}`(40为NI直接视为-20时的固定值)，priority取值范围是[1,99](线程的属性，可以修改)，PRI值取值范围是[41,139]
3. 对于非实时线程，该值为`139-PR`，PRI值取值范围是[0,39]
4. 对于实时线程，实际**反向**对应基础优先级的[1,99]部分
5. 对于非实时线程，实际**反向**对应基础优先级的[100,139]部分
6. 因为priority取值不能为0，故基础优先级的0未使用